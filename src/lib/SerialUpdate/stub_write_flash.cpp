/*
 * SPDX-FileCopyrightText: 2016 Cesanta Software Limited
 *
 * SPDX-License-Identifier: GPL-2.0-or-later
 *
 * SPDX-FileContributor: 2016-2022 Espressif Systems (Shanghai) CO LTD
 */

#if defined(PLATFORM_ESP32) && defined(TARGET_RX)

#include "stub_write_flash.h"
#include "slip.h"
#include "soc_support.h"
#include "stub_flasher.h"
#include "targets.h"

#include <Update.h>

/* local flashing state

   This is wrapped in a structure because gcc 4.8
   generates significantly more code for ESP32
   if they are static variables (literal pool, I think!)
*/
static struct
{
    /* set by flash_begin, cleared by flash_end */
    bool in_flash_mode;
    /* number of output bytes remaining to write */
    uint32_t remaining;
    /* last error generated by a data packet */
    esp_command_error last_error;

    uint8_t last_buf[MAX_WRITE_BLOCK];
    uint32_t last_length;
    uint32_t last_end;
    MD5Builder md5;
} fs;

bool is_in_flash_mode(void)
{
    return fs.in_flash_mode;
}

esp_command_error get_flash_error(void)
{
    return fs.last_error;
}

esp_command_error handle_flash_get_md5sum(uint32_t addr, uint32_t len)
{
    /* ESP32 ROM sends as hex, but stub just send raw bytes - esptool.py can handle either. */
    fs.md5.add(fs.last_buf, len - fs.last_end);
    fs.md5.calculate();
    uint8_t md5[16];
    fs.md5.getBytes(md5);
    SLIP_send_frame_data_buf(md5, sizeof(md5));
    return ESP_UPDATE_OK;
}

esp_command_error handle_flash_begin(uint32_t total_size, uint32_t offset)
{
    fs.in_flash_mode = true;
    fs.remaining = total_size;
    if (total_size != 0)
    {
        Update.begin(total_size);
        fs.md5.begin();
    }
    fs.last_length = 0;
    fs.last_end = 0;
    return ESP_UPDATE_OK;
}

void handle_flash_data(uint8_t *data_buf, uint32_t length)
{
    if (fs.last_length)
    {
        fs.md5.add(fs.last_buf, fs.last_length);
        fs.last_end += fs.last_length;
    }
    if (length > fs.remaining)
    {
        /* Trim the final block, as it may have padding beyond
            the length we are writing */
        length = fs.remaining;
    }
    memcpy(fs.last_buf, data_buf, length);
    fs.last_length = length;
    fs.remaining -= length;
    Update.write(data_buf, length);

    fs.last_error = ESP_UPDATE_OK;
}

esp_command_error handle_flash_end(void)
{
    if (!fs.in_flash_mode)
    {
        return ESP_NOT_IN_FLASH_MODE;
    }

    if (fs.remaining > 0)
    {
        return ESP_NOT_ENOUGH_DATA;
    }

    fs.in_flash_mode = false;

    if (!Update.end(true))
    {
        switch (Update.getError())
        {
        case UPDATE_ERROR_SPACE:
            return ESP_TOO_MUCH_DATA;
        case UPDATE_ERROR_SIZE:
            return ESP_NOT_ENOUGH_DATA;
        case UPDATE_ERROR_MD5:
            return ESP_BAD_DATA_CHECKSUM;
        default:
            return ESP_INVALID_COMMAND;
        }
    }
    return fs.last_error;
}
#endif